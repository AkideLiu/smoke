#!/usr/bin/env ruby

GREEN = "\e[32m"
RED = "\e[31m"
RESET = "\e[0m"

SPECIAL = '#;&."\',\\/`:!*?$*(){}[]><|~'.chars

FILE_TYPES = {
  args: { extension: '.args' },
  input: { extension: '.in' },
  output: { extension: /^\.out.*/ }
}

def run_application application, args, input
  IO.popen "#{application} #{escape args}", 'r+' do |io|
    io.write input
    io.close_write
    io.read.strip
  end
end

def read_tests test_case
  Dir.glob("#{test_case}/*.*")
    .collect { |file| [File.basename(file, '.*'), File.extname(file), file] }
    .group_by { |name, extension, file| name }
    .sort_by { |name, _| name }
    .collect { |name, files|
      categorized_files = files
        .collect { |_, extension, file| [look_up_extension(extension), file] }
        .reject { |type, file| type.nil? }
        .collect { |type, file| [type, IO.read(file).strip] }
        .group_by { |type, file| type }
        .collect { |type, types_and_files| [type, types_and_files.collect { |_, file| file }] }
        .to_h
      [name, categorized_files]
    }
    .collect { |name, files|
      args = (files[:args] || [''])[0]
      input = (files[:input] || [''])[0]
      expected = files[:output] || []
      [name, args, input, expected]
    }
end

def run_tests tests, application
  tests.each do |name, args, input, expected|
    puts name
    next failed "no outputs provided" if expected.length == 0

    output = run_application application, args, input

    next failed "program exited with status code #{$?}" if $?.exitstatus > 0

    unless expected.include? output
      expected = expected.collect { |e| highlight(e) }
      info = []
      info << ['args', highlight(args)] unless args.empty?
      info << ['input', highlight(input)] unless input.empty?
      info << ['output', highlight(output)]
      info << ['expected', expected.length == 1 ? expected[0]
                             : "#{expected[0...expected.length - 1].join(', ')} or #{expected[-1]}"]

      next failed *(info.collect { |name, value| Kernel.format '%-9s %s', (name + ':'), value })
    end

    succeeded 'succeeded'
  end
end

def print_summary
  puts
  if @failures > 0
    puts red "#{@successes + @failures} tests, #{@failures} failures"
  else
    puts green "#{@successes + @failures} tests, #{@failures} failures"
  end
end

def green string
  "#{GREEN}#{string}#{RESET}"
end

def red string
  "#{RED}#{string}#{RESET}"
end

@successes = 0
def succeeded *messages
  puts green messages.collect { |message| '  ' + message }.join "\n"
  @successes += 1
end

@failures = 0
def failed *messages
  puts red messages.collect { |message| '  ' + message }.join "\n"
  @failures += 1
end

def look_up_extension(extension)
  type, _ = FILE_TYPES.find { |_, configuration|
    case configuration[:extension]
    when String
      extension == configuration[:extension]
    when Regexp
      extension =~ configuration[:extension]
    end
  }
  type
end

def escape args
  args.chars.collect { |c| SPECIAL.include?(c) ? '\\' + c : c }.join
end

def highlight text
  highlighted = text.include?("\e") ? (RESET + text + RED) : text
  highlighted.gsub("\n", "\n            ")
end

run_tests(read_tests(ARGV[0]), ARGV[1])
print_summary
