#!/usr/bin/env ruby

require 'open3'
require 'optparse'

GREEN = "\e[32m"
RED = "\e[31m"
RESET = "\e[0m"

SPECIAL = '#;&."\',\\/`:!*?$*(){}[]><|~'.chars

FILE_TYPES = {
  args: { extension: '.args' },
  input: { extension: '.in' },
  output: { extension: /^\.out.*/ },
  error: { extension: /^\.err.*/ },
  status: { extension: /^\.status/ },
}

def run_application application, args, input
  Open3.popen3 "#{application} #{escape args}" do |stdin, stdout, stderr, wait_threads|
    stdin.write input
    stdin.close_write
    [stdout.read.strip, stderr.read.strip, wait_threads.value.exitstatus]
  end
end

def read_tests test_case
  Dir.glob("#{test_case}/*.*")
    .collect { |file| [File.basename(file, '.*'), File.extname(file), file] }
    .group_by { |name, extension, file| name }
    .sort_by { |name, _| name }
    .collect { |name, files|
      categorized_files = files
        .collect { |_, extension, file| [look_up_extension(extension), file] }
        .reject { |type, file| type.nil? }
        .collect { |type, file| [type, IO.read(file).strip] }
        .group_by { |type, file| type }
        .collect { |type, types_and_files| [type, types_and_files.collect { |_, file| file }] }
        .to_h
      [name, categorized_files]
    }
    .collect { |name, files|
      args = (files[:args] || [''])[0]
      input = (files[:input] || [''])[0]
      expected_output = files[:output] || []
      expected_error = files[:error] || []
      expected_status = (files[:status] || ['0'])[0].to_i
      [name, args, input, expected_output, expected_error, expected_status]
    }
end

def run_tests tests, application
  tests.each do |name, args, input, expected_output, expected_error, expected_status|
    puts name
    next failed "no outputs provided" if expected_output.empty? and expected_error.empty?

    output, error, status = run_application application, args, input

    unless (expected_output.empty? || expected_output.include?(output)) and
           (expected_error.empty? || expected_error.include?(error)) and
           status == expected_status
      expected_output = expected_output.collect { |e| highlight(e) }
      info = []
      info << ['args', highlight(args)] unless args.empty?
      info << ['input', highlight(input)] unless input.empty?
      info += add_if(status != expected_status, status, [expected_status], 'status')
      info += add_if(!output.empty? || !expected_output.empty?, output, expected_output, 'output')
      info += add_if(!error.empty? || !expected_error.empty?, error, expected_error, 'error')

      next failed(*(info.collect { |key, value| Kernel.format '%-17s %s', (key + ':'), value }))
    end

    succeeded 'succeeded'
  end
end

def add_if(condition, actual, expected, name)
  if condition
    [
      ["actual #{name}", highlight(actual.to_s)],
      ["expected #{name}",
       expected.length == 1 ?
         expected[0] :
         "#{expected[0...expected.length - 1].join(', ')} or #{expected[-1]}"]
    ]
  else
    []
  end
end

def print_summary
  puts
  if @failures > 0
    puts red "#{@successes + @failures} tests, #{@failures} failures"
  else
    puts green "#{@successes + @failures} tests, #{@failures} failures"
  end
end

def green string
  if @options[:color]
    "#{GREEN}#{string}#{RESET}"
  else
    string
  end
end

def red string
  if @options[:color]
    "#{RED}#{string}#{RESET}"
  else
    string
  end
end

@successes = 0
def succeeded *messages
  puts green messages.collect { |message| '  ' + message }.join "\n"
  @successes += 1
end

@failures = 0
def failed *messages
  puts red messages.collect { |message| '  ' + message }.join "\n"
  @failures += 1
end

def look_up_extension(extension)
  type, _ = FILE_TYPES.find { |_, configuration|
    case configuration[:extension]
    when String
      extension == configuration[:extension]
    when Regexp
      extension =~ configuration[:extension]
    end
  }
  type
end

def escape args
  args.chars.collect { |c| SPECIAL.include?(c) ? '\\' + c : c }.join
end

def highlight text
  highlighted = text.include?("\e") ? (RESET + text + RED) : text
  highlighted.gsub("\n", "\n" + (' ' * 20))
end

def parse_options
  options = {
    color: $stdout.isatty
  }

  immediate_exit_code = 0

  parser = OptionParser.new { |opts|
    opts.banner = 'Usage: smoke [options] TEST-DIRECTORY COMMAND'

    opts.on '-c', '--[no-]color', 'Color output' do |color|
      options[:color] = color
    end

    opts.on '-h', '--help', 'Help me' do |color|
      puts opts
      exit immediate_exit_code
    end
  }

  parser.parse!

  if ARGV.length != 2
    immediate_exit_code = 2
    parser.parse!(%w{--help})
  end
  [options, ARGV]
end

@options, @args = parse_options
run_tests(read_tests(@args[0]), @args[1])
print_summary
exit 1 if @failures > 0
